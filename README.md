Цикломатическая сложность кода

Есть несколько формул для вычисления ЦС. В любом случае, для их понимания сначала необходимо усвоить общую теорию графов и иметь представление о графе потока управления программы (Control Flow Graph, далее CFG). 

Поскольку в нашем курсе тестировщиков этому не учат, то просто скопируем текст из русской статьи из Википедии и побробуем разобраться на очень простом примере:

Цикломатическая сложность части программного кода — количество линейно независимых маршрутов через программный код. Например, если исходный код не содержит никаких точек ветвления или циклов, то сложность равна единице, поскольку есть только единственный маршрут через код. Если код имеет единственный оператор IF, содержащий простое условие, то существует два пути через код: один если условие оператора IF имеет значение TRUE и один — если FALSE.

Математически цикломатическая сложность структурированной программы определяется с помощью ориентированного графа, узлами которого являются блоки программы, соединенные рёбрами, если управление может переходить с одного блока на другой. Тогда сложность определяется как:[3]:

M = E − N + 2P,

где:

M = цикломатическая сложность,
E = количество рёбер в графе,
N = количество узлов в графе,
P = количество компонент связности.

Для примера рассмотрим метод int next() из класса Radio, который устанавливает следующий номер радиостанции с определенным условием:

"Если текущая радиостанция - 9 и клиент нажал на кнопку next (следующая) на пульте, то текущей должна стать 0-ая"

public int next() {
        int num = getStationNumber();
        if (num == LAST_STATION) {
            num = FIRST_STATION;
        } else
            ++num;

        return tune(num);
    }

Теперь построим диаграмму блок-схемы метода (CFG activity diagram):

https://app.code2flow.com/Odmx0A.svg

На диаграмме наглядно видно, что в этом методе есть только два линейно независимых маршрута. Соответственно, по определению: ЦС = 2.

Это подтверждается формулой: 

N = 5, E = 5, P = 1 

M = 2

JaCoCo тоже с нами согласен, значит только для этого метода (а всего таких пять) придется написать два unit-теста, чтобы обеспечить 100% покрытие по метрике BRANCHES (ветвление).

Ограничение сложности при разработке

Автор метрики (McCabe) рекомендует в 1976 году, "чтобы программистов обязывали вычислять сложность разрабатываемых ими модулей и разделять модули на более мелкие всякий раз, когда цикломатическая сложность этих модулей превысит десять" (Википедия).

Однако, следует заметить, что аксиоматически этот метод refactoring (декомпозиция) не уменьшает общую ЦС кода, обусловленную бизнес-логикой, а главное конкретной реализацией implementaion сложного модуля (unit) разработчиком.

Кроме того, согласно последним исследованиям ЦС сама по себе не добавляет новой информации о сложности кода. 

Плохой, нечитаемый и непонятный код и так хорошо видно! Но тестировщикам все равно придется писать на него тесты. Чем выше ЦС, тем больше тестов (а платят только за потрачанное время жизни, а не сдельно за каждый тест =)

Поэтому некоторые разработчики для оценки сложности предпочитают соотносить суммарную ЦС с количеством строк всего кода проекта. Чем меньше это отношение, тем лучше.

Назовем эту метрику СС100 и выразим ее процентах от общего количества сторок кода, который потребовался для решения этой задачи (не считая кода тестов): 

СС100 = 17 (СС) / 34 (LoC) = 54%

Видно, что с точки зрения тестировщика код достаточно сложный. Для решения первой задачи, где требуется 100% покрытие по Ветвлению, пришлось написать 10 тестов на 34 строки кода.

Это целых 117 строк кода (да, более простого без логики, но все же). То есть для написания тестов потребовалось в три раза больше кода с комментариями*, чем собственно project codebase!

*) для тех, кто будет пользоваться тестами после нас

В заключение заметим, что помимо декомпозиции*,  можно и нужно использовать ОО свойства языка программирования, такие как: полиморфизм, перегрузка и проч. Это позволит заметно снизить ЦС и, соответственно, количество тестов.

В данном случае использовались только процедурные свойства Java, поэтому для решения первой задачи нужно написать никак не меньше меньше 10 тестов, чтобы "добиться 100% покрытия".  

*) декомпозиция делает исходный код несколько проще с точки зрения читабельности и поддержки, но при этом все-таки не уменьшает общую ЦС, а следовательно количество необходимых unit-тестов